---
date: 2025-02-28
comments: true
categories:
    - 游戏引擎
tags: note
draft: true
---

# JobSystem的学习感悟
&emsp;&emsp;从单线程到多线程，再到JobSystem(非unity), 游戏引擎的发展有条清晰的发展路线。本文主要记录了在JobSystem这个设计下的学习和实践。
<!-- more -->
&emsp;&emsp;当前, 游戏引擎的一个发展方向就是充分利用多线程能力，Unity和Unreal都有自己的一套多线程框架。多线程是一个复杂的主题，在它基础上再封装更加考验系统开发者的功底。

## 从引擎的心跳开始
&emsp;&emsp;游戏开发中的最常见的函数就是update,它提供游戏中对象在一定时间获得执行程序的能力。但是你是否想过在偌大的游戏引擎中, 大量对象的update是如何进行的?大道至简，老开发选手会说update的“根”来自游戏引擎的主循环。这种说法简单，不过也丢失了一些“细节”。关于这些细节的发展，也影响着引擎代码设计。

![alt text](img/engine_multi.png)

&emsp;&emsp;游戏的最初的单线程, Update, Render两个函数交替执行, 代码相对简单。当多核CPU登场，自然地会想着通过多线程来提升引擎性能。于是乎，一些引擎地做法是将Update与Render的逻辑分拆到不同线程，即thread-on-system模式。配合逻辑线程比渲染线程领先1帧的执行方式，将逻辑线程与渲染线程并行执行一帧来获得性能提升。引擎就拥有了多个互相有制约的心跳。

&emsp;&emsp;多线程的引入也带来编程的复杂度。首先就是线程安全, 小bug自不必说, 在大方面上一个重要的设计转变是游戏状态的线程同步。多线程的执行模式会要求引擎要额外保存1帧的游戏状态(额外保存的一帧在渲染线程中使用)。这帧游戏状态的缓存算法当然也有优化空间, 但复杂度就不可避免地提升了。

&emsp;&emsp;当艰难地解决完多线程带来的线程安全问题后，回过头来看，多线程真的解决性能问题吗？答案是有，但不是全部。“一核有难多核围观”可以不太准确地回答这个问题，即线程的负载不平衡导致的性能问题。此时，一帧的时长取决于工作负载大的任务(有渲染与逻辑同步的设计), 此时负载小的线程会处于等待“摸鱼”状态。也就是说按照“System-on-thread”的设计方式存在负载均衡的问题。那么，在多线程的基础上如何充分榨干CPU性能？

<!-- ![alt text](img/jobfy.png)

![alt text](img/jobfy_detail.png) -->

&emsp;&emsp;"System-on-thread"的模式一个存在的问题是分割逻辑粒度大。逻辑复杂不等于执行时间长，但粒度大意味着性能的可控性小。基于这种思维，一种解决方案是将多线程与多线程逻辑分离。在分离的基础上，将逻辑细分形成一个个独立的Job。其中, Job是存在依赖关系的功能单元，JobSystem需要解决Job依赖关系的同时，并行化Job执行; Worker是执行线程，workers从队列中获取并执行Job。JobSystem解决问题了嘛？其实还没有。JobSystem只是分离的逻辑与线程，Job的粒度还是由程序设计者来设置。程序设计者需要充分理解引擎中不同的执行阶段，拆分功能形成Job。但是，好处也很明显，现在的引擎框架程序线程功能与模块无关，充分发挥多线程能力的关键点在于如何Job的拆分。

## JobSystem方法
### 核心概念
&emsp;&emsp; todo
&emsp;&emsp;

### 实现效果
&emsp;&emsp; todo

### 是否需要依赖图？


## 总结


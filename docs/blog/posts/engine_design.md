---
date: 2025-02-28
comments: true
categories:
    - 游戏引擎
tags: note
draft: true
---

# 简述引擎结构设计
从单线程到多线程，再到jobSystem, 游戏引擎的发展有条清洗的发展路线，本文主要简单记录用这个发展过程的理解。

<!-- more -->
## 从引擎的心跳开始
&emsp;&emsp;游戏开发中的最常见的函数就是update,它提供游戏中对象在一定时间获得执行程序的能力。但是你是否想过在偌大的游戏引擎中, 大量对象的update是如何进行的?大道至简，老开发选手会说update的“根”来自游戏引擎的主循环。这种说法简单，不过也丢失了一些“细节”。关于这些细节的发展，也影响着引擎代码设计。

![alt text](img/engine_multi.png)

&emsp;&emsp;游戏的最初的单线程, Update, Render两个函数交替执行, 代码相对简单。当多核CPU登场，自然地会想着通过多线程来提升引擎性能。于是乎，一些引擎地做法是将Update与Render的逻辑分拆到不同线程，即thread-on-system模式。配合逻辑线程比渲染线程领先1帧的执行方式，将逻辑线程与渲染线程并行执行一帧来获得性能提升。

&emsp;&emsp;多线程的引入也带来编程的复杂度。首先就是线程安全, 小bug自不必说, 在大方面上一个重要的设计转变是游戏状态的线程同步。多线程的执行模式会要求引擎要额外保存1帧的游戏状态(额外保存的一帧在渲染线程中使用)。这帧游戏状态的缓存算法当然也有优化空间, 但复杂度就不可避免地提升了。

&emsp;&emsp;当艰难地解决完多线程带来的线程安全问题后，回过头来看，多线程真的解决性能问题吗？答案是有，但不是全部。“一核有难多核围观”可以不太准确地回答这个问题，即线程的负载不平衡导致的性能问题。当逻辑负载或渲染负载不平衡是，一帧的时长取决于工作负载大的任务(有渲染与逻辑同步的设计), 此时负载小的线程会处于等待“摸鱼”状态。也就是说按照“System-on-thread”的设计方式不存在负载均衡上的控制能力。那么，在多线程的基础上如何充分榨干CPU性能？

&emsp;&emsp;"System-on-thread"的模式一个存在的问题是分割逻辑粒度大。逻辑复杂不等于执行时间长，但粒度大意味着性能的可控性小。基于这种思维，一种解决方案是将多线程与多线程逻辑分离。在分离的基础上，将逻辑细分形成一个个独立的Job。Job是存在依赖关系的功能单元，JobSystem需要解决依赖关系的同时，并行化Job执行。至于多线程变成了JobSystem管理下的workers, workers从队列中获取并执行Job。

![alt text](img/jobfy.png)

![alt text](img/jobfy_detail.png)

&emsp;&emsp;JobSystem解决问题了嘛？其实还没有。JobSystem只是分离的逻辑与线程，Job的粒度还是由程序设计者来设置。程序设计者需要充分理解引擎中不同的执行阶段，拆分功能形成Job。如上图，功能被拆分成若干个任务阶段，不同阶段在实际中需要同步点。

